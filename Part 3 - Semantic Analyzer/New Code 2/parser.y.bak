%{
	#include <stdlib.h>
	#include <stdio.h>
	int yyerror(char *msg);

	#include "lex.yy.c"

	#define SYMBOL_TABLE symbol_table_list[current_scope].symbol_table

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#include <string.h>

#define HASH_TABLE_SIZE 100
#define NUM_TABLES 10

int table_index = 0;
int current_scope = 0;

/* struct to hold each entry */
struct entry_s
{
	char* lexeme;
	double value;
	int data_type;
	int* parameter_list; // for functions
	int array_dimension;
	int is_constant;
	int num_params;
	struct entry_s* successor;
};

typedef struct entry_s entry_t;

/* Wrapper for symbol table with pointer to symbol table of parent scope */
struct table_s
{
	entry_t** symbol_table;
	int parent;
};

typedef struct table_s table_t;

extern table_t symbol_table_list[NUM_TABLES];

/* Create a new hash_table. */
entry_t** create_table()
{
	entry_t** hash_table_ptr = NULL; // declare a pointer

	/* Allocate memory for a hashtable array of size HASH_TABLE_SIZE */
	if( ( hash_table_ptr = malloc( sizeof( entry_t* ) * HASH_TABLE_SIZE ) ) == NULL )
    	return NULL;

	int i;

	// Intitialise all entries as NUscopeLL
    for( i = 0; i < HASH_TABLE_SIZE; i++ )
	{
		hash_table_ptr[i] = NULL;
	}

	return hash_table_ptr;
}

int create_new_scope()
{
	table_index++;

	symbol_table_list[table_index].symbol_table = create_table();
	symbol_table_list[table_index].parent = current_scope;

	return table_index;
}

int exit_scope()
{
	return symbol_table_list[current_scope].parent;
}
/* Generate hash from a string. Then generate an index in [0, HASH_TABLE_SIZE) */
uint32_t hash( char *lexeme )
{
	size_t i;
	uint32_t hash;

	/* Apply jenkin's hash function
	* https://en.wikipedia.org/wiki/Jenkins_hash_function#one-at-a-time
	*/
	for ( hash = i = 0; i < strlen(lexeme); ++i ) {
        hash += lexeme[i];
        hash += ( hash << 10 );
        hash ^= ( hash >> 6 );
    }
	hash += ( hash << 3 );
	hash ^= ( hash >> 11 );
    hash += ( hash << 15 );

	return hash % HASH_TABLE_SIZE; // return an index in [0, HASH_TABLE_SIZE)
}

/* Create an entry for a lexeme, token pair. This will be called from the insert function */
entry_t *create_entry( char *lexeme, int value, int data_type )
{
	entry_t *new_entry;

	/* Allocate space for new_entry */
	if( ( new_entry = malloc( sizeof( entry_t ) ) ) == NULL ) {
		return NULL;
	}
	/* Copy lexeme to new_entry location using strdup (string-duplicate). Return NULL if it fails */
	if( ( new_entry->lexeme = strdup( lexeme ) ) == NULL ) {
		return NULL;
	}

	new_entry->value = value;
	new_entry->successor = NULL;
	new_entry->parameter_list = NULL;
	new_entry->array_dimension = -1;
	new_entry->is_constant = 0;
	new_entry->num_params = 0;
	new_entry->data_type = data_type;

	return new_entry;
}

/* Search for an entry given a lexeme. Return a pointer to the entry of the lexeme exists, else return NULL */
entry_t* search(entry_t** hash_table_ptr, char* lexeme)
{
	uint32_t idx = 0;
	entry_t* myentry;

    // get the index of this lexeme as per the hash function
	idx = hash( lexeme );

	/* Traverse the linked list at this idx and see if lexeme exists */
	myentry = hash_table_ptr[idx];

	while( myentry != NULL && strcmp( lexeme, myentry->lexeme ) != 0 )
	{
		myentry = myentry->successor;
	}

	if(myentry == NULL) // lexeme is not found
		return NULL;

	else // lexeme found
		return myentry;

}

// Search recursively in every parent scope for lexeme
entry_t* search_recursive(char* lexeme)
{
	int idx = current_scope;
	entry_t* finder = NULL;

	while(idx != -1)
	{
		finder = search(symbol_table_list[idx].symbol_table, lexeme);

		if(finder != NULL)
			return finder;

		idx = symbol_table_list[idx].parent;
	}

	return finder;
}
/* Insert an entry into a hash table. */
entry_t* insert( entry_t** hash_table_ptr, char* lexeme, int value, int data_type)
{
	// Make sure you pass the current scope symbol table here
	entry_t* finder = search( hash_table_ptr, lexeme );
	if( finder != NULL) // If lexeme already exists, don't insert, return NULL
	{
		if(finder->is_constant)
			return finder;
		return NULL; //capture this is callee code and do necessary error handling
	}

	uint32_t idx;
	entry_t* new_entry = NULL;
	entry_t* head = NULL;

	idx = hash( lexeme ); // Get the index for this lexeme based on the hash function
	new_entry = create_entry( lexeme, value, data_type ); // Create an entry using the <lexeme, token> pair

	if(new_entry == NULL) // In case there was some error while executing create_entry()
	{
		printf("Insert failed. New entry could not be created.");
		exit(1);
	}

	head = hash_table_ptr[idx]; // get the head entry at this index

	if(head == NULL) // This is the first lexeme that matches this hash index
	{
		hash_table_ptr[idx] = new_entry;
	}
	else // if not, add this entry to the head
	{
		new_entry->successor = hash_table_ptr[idx];
		hash_table_ptr[idx] = new_entry;
	}
	return hash_table_ptr[idx];
}

// This is called after a function call to check if param list match
int check_parameter_list(entry_t* entry, int* list, int m)
{
	int* parameter_list = entry->parameter_list;

	if(m != entry->num_params)
	{
		yyerror("Number of parameters and arguments do not match");
	}

	int i;
	for(i=0; i<m; i++)
	{
		if(list[i] != parameter_list[i])
		yyerror("Parameter and argument types do not match");
	}

	return 1;
}

void fill_parameter_list(entry_t* entry, int* list, int n)
{
	entry->parameter_list = (int *)malloc(n*sizeof(int));

	int i;
	for(i=0; i<n; i++)
	{
		entry->parameter_list[i] = list[i];
	}
	entry->num_params = n;
}


void print_dashes(int n)
{
  printf("\n");

	int i;
	for(i=0; i< n; i++)
	printf("=");
	printf("\n");
}

// Traverse the hash table and print all the entries
void display_symbol_table(entry_t** hash_table_ptr)
{
	int i;
	entry_t* traverser;

	print_dashes(100);

  printf(" %-20s %-20s %-20s %-20s %-20s\n","lexeme","data-type","array_dimension","num_params","param_list");

	print_dashes(100);

	for( i=0; i < HASH_TABLE_SIZE; i++)
	{
		traverser = hash_table_ptr[i];
		while( traverser != NULL)
		{
			printf(" %-20s %-20d %-20d ", traverser->lexeme, traverser->data_type, traverser->array_dimension);

			printf(" %-20d", traverser->num_params);

			int j;
			for(j=0; j < traverser->num_params; j++)
			printf(" %d",traverser->parameter_list[j]);
			printf("\n");

			traverser = traverser->successor;
		}
	}

	print_dashes(100);

}

void display_constant_table(entry_t** hash_table_ptr)
{
	int i;
	entry_t* traverser;

	print_dashes(25);

	printf(" %-10s %-10s \n","lexeme","data-type");

	print_dashes(25);

	for( i=0; i < HASH_TABLE_SIZE; i++)
	{
		traverser = hash_table_ptr[i];
		while( traverser != NULL)
		{
			printf(" %-10s %-10d \n", traverser->lexeme, traverser->data_type);
			traverser = traverser->successor;
		}
	}

	print_dashes(25);
}

void display_all()
{
		int i;
		for(i=0; i<=table_index; i++)
		{
			printf("Scope: %d\n",i);
			display_symbol_table(symbol_table_list[i].symbol_table);
			printf("\n\n");
		}
}


	entry_t** constant_table;

	int current_dtype;

	table_t symbol_table_list[NUM_TABLES];

	int is_declaration = 0;
	int is_loop = 0;
	int is_func = 0;
	int func_type;
	extern int yylinno;
	int param_list[10];
	int p_idx = 0;
	int p=0;
	int rhs = 0;

	void type_check(int,int,int);
%}

%union
{
	int data_type;
	entry_t* entry;
}

%token <entry> IDENTIFIER

 /* Constants */
%token <entry> DEC_CONSTANT HEX_CONSTANT CHAR_CONSTANT FLOAT_CONSTANT
%token STRING

 /* Logical and Relational operators */
%token LOGICAL_AND LOGICAL_OR LS_EQ GR_EQ EQ NOT_EQ

 /* Short hand assignment operators */
%token MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN SUB_ASSIGN
%token INCREMENT DECREMENT

 /* Data types */
%token SHORT INT LONG LONG_LONG SIGNED UNSIGNED CONST VOID CHAR FLOAT

 /* Keywords */
%token IF FOR WHILE CONTINUE BREAK RETURN

%type <entry> identifier
%type <entry> constant
%type <entry> array_index

%type <data_type> sub_expr
%type <data_type> unary_expr
%type <data_type> arithmetic_expr
%type <data_type> assignment_expr
%type <data_type> function_call
%type <data_type> array_access
%type <data_type> lhs

%left ','
%right '='
%left LOGICAL_OR
%left LOGICAL_AND
%left EQ NOT_EQ
%left '<' '>' LS_EQ GR_EQ
%left '+' '-'
%left '*' '/' '%'
%right '!'


%nonassoc UMINUS
%nonassoc LOWER_THAN_ELSE
%nonassoc ELSE


%%

 /* Program is made up of multiple builder blocks. */
starter: starter builder
			 | builder;

 /* Each builder block is either a function or a declaration */
builder: function
			 | declaration
			 ;

 /* This is how a function looks like */
function: type
					identifier 											{
																						func_type = current_dtype;
																						is_declaration = 0;
																						current_scope = create_new_scope();
																					}

					'(' argument_list ')' 					{
																						is_declaration = 0;
																						fill_parameter_list($2,param_list,p_idx);
																						p_idx = 0;
																						is_func = 1;
																						p=1;
																					}

					compound_stmt										{
																						is_func = 0;
																					}
          ;
 /* Now we will define a grammar for how types can be specified */

type : data_type pointer
     {is_declaration = 1; }
     | data_type
     {is_declaration = 1; }
		 ;

pointer: '*' pointer
    	 | '*'
       ;

data_type : sign_specifier type_specifier
    			| type_specifier
    			;

sign_specifier : SIGNED
    					 | UNSIGNED
    			 		 ;

type_specifier :INT                    {current_dtype = INT;}
    |SHORT INT                         {current_dtype = SHORT;}
    |SHORT                             {current_dtype = SHORT;}
    |LONG                              {current_dtype = LONG;}
		|LONG INT                          {current_dtype = LONG;}
    |LONG_LONG                         {current_dtype = LONG_LONG;}
    |LONG_LONG INT                     {current_dtype = LONG_LONG;}
		|CHAR 														 {current_dtype = CHAR;}
		|FLOAT 														 {current_dtype = FLOAT;}
		|VOID															 {current_dtype = VOID;}
    ;

 /* grammar rules for argument list */
 /* argument list can be empty */
argument_list : arguments
    					|
    					;
 /* arguments are comma separated TYPE ID pairs */
arguments : arguments ',' arg
    			| arg
    			;

 /* Each arg is a TYPE ID pair */
arg : type identifier									{param_list[p_idx++] = $2->data_type;}
    ;

 /* Generic statement. Can be compound or a single statement */
stmt:compound_stmt
    |single_stmt
    ;

 /* The function body is covered in braces and has multiple statements. */
compound_stmt :
							'{' 							{
																		if(!p)current_scope = create_new_scope();
																		else p = 0;
																}

							statements

							'}' 						{current_scope = exit_scope();}
    ;

statements:statements stmt
    |
    ;

 /* Grammar for what constitutes every individual statement */
single_stmt :if_block
    |for_block
    |while_block
    |declaration
    |function_call ';'
		|RETURN ';'								  {
																	if(is_func)
																	{
																		if(func_type != VOID)
																			yyerror("return type (VOID) does not match function type");
																	}
																  else yyerror("return statement not inside function definition");
																}

		|CONTINUE ';'							 {if(!is_loop) {yyerror("Illegal use of continue");}}
		|BREAK ';'                 {if(!is_loop) {yyerror("Illegal use of break");}}

		|RETURN sub_expr ';'			 {
																	if(is_func)
																	{
																		if(func_type != $2)
																			yyerror("return type does not match function type");
																	}
																	else yyerror("return statement not in function definition");
															 }
    ;

for_block:FOR '(' expression_stmt  expression_stmt ')' {is_loop = 1;} stmt {is_loop = 0;}
    		 |FOR '(' expression_stmt expression_stmt expression ')' {is_loop = 1;} stmt {is_loop = 0;}
    		 ;

if_block:IF '(' expression ')' stmt 								%prec LOWER_THAN_ELSE
				|IF '(' expression ')' stmt ELSE stmt
    ;

while_block: WHILE '(' expression	')' {is_loop = 1;} stmt {is_loop = 0;}
		;

declaration: type  declaration_list ';'
           {is_declaration = 0; }
					 | declaration_list ';'
					 | unary_expr ';'


declaration_list: declaration_list ',' sub_decl
								|sub_decl
								;

sub_decl: assignment_expr
    		|identifier
    		|array_access
				;

/* This is because we can have empty expession statements inside for loops */
expression_stmt: expression ';'
    					 | ';'
    			 		 ;

expression: expression ',' sub_expr
    			| sub_expr
					;

sub_expr:
    sub_expr '>' sub_expr															  {type_check($1,$3,2); $$ = $1;}
    |sub_expr '<' sub_expr															{type_check($1,$3,2); $$ = $1;}
    |sub_expr EQ sub_expr																{type_check($1,$3,2); $$ = $1;}
    |sub_expr NOT_EQ sub_expr														{type_check($1,$3,2); $$ = $1;}
    |sub_expr LS_EQ sub_expr														{type_check($1,$3,2); $$ = $1;}
    |sub_expr GR_EQ sub_expr														{type_check($1,$3,2); $$ = $1;}
		|sub_expr LOGICAL_AND sub_expr											{type_check($1,$3,2); $$ = $1;}
		|sub_expr LOGICAL_OR sub_expr												{type_check($1,$3,2); $$ = $1;}
		|'!' sub_expr																				{$$ = $2;}
		|arithmetic_expr																		{$$ = $1;}
    |assignment_expr																		{$$ = $1;}
		|unary_expr																					{$$ = $1;}
    ;


assignment_expr :
		lhs assign_op  arithmetic_expr												{type_check($1,$3,1); $$ = $3; rhs=0;}
    |lhs assign_op  array_access													{type_check($1,$3,1); $$ = $3;rhs=0;}
    |lhs assign_op  function_call												{type_check($1,$3,1); $$ = $3;rhs=0;}
	|lhs assign_op  unary_expr                                                  {type_check($1,$3,1); $$ = $3;rhs=0;}
		|unary_expr assign_op  unary_expr										{type_check($1,$3,1); $$ = $3;rhs=0;}
    ;

unary_expr:	identifier INCREMENT												{$$ = $1->data_type;}
					| identifier DECREMENT												{$$ = $1->data_type;}
					| DECREMENT identifier												{$$ = $2->data_type;}
					| INCREMENT identifier												{$$ = $2->data_type;}

lhs: identifier																					{$$ = $1->data_type;}
   | array_access																				{$$ = $1;}
	 ;

identifier:IDENTIFIER                                    {
                                                                    if(is_declaration
                                                                    && !rhs) 
                                                                    {
                                                                        $1 = insert(SYMBOL_TABLE,yytext,INT_MAX,current_dtype);
                                                                        if($1 == NULL) yyerror("Redeclaration of variable");
                                                                    }
                                                                    else
                                                                    {
                                                                        $1 = search_recursive(yytext);
                                                                        if($1 == NULL) yyerror("Variable not declared");
                                                                    }
                                                                    $$ = $1;
                                                            }
    			 ;

assign_op:'=' {rhs=1;}
    |ADD_ASSIGN {rhs=1;} 
    |SUB_ASSIGN {rhs=1;}
    |MUL_ASSIGN {rhs=1;}
    |DIV_ASSIGN {rhs=1;}
    |MOD_ASSIGN {rhs=1;}
    ;

arithmetic_expr: arithmetic_expr '+' arithmetic_expr				{type_check($1,$3,0);}
    |arithmetic_expr '-' arithmetic_expr										{type_check($1,$3,0);}
    |arithmetic_expr '*' arithmetic_expr										{type_check($1,$3,0);}
    |arithmetic_expr '/' arithmetic_expr										{type_check($1,$3,0);}
		|arithmetic_expr '%' arithmetic_expr										{type_check($1,$3,0);}
		|'(' arithmetic_expr ')'																{$$ = $2;}
    |'-' arithmetic_expr %prec UMINUS												{$$ = $2;}
    |identifier																							{$$ = $1->data_type;}
    |constant																								{$$ = $1->data_type;}
    ;

constant: DEC_CONSTANT 												{$1->is_constant=1; $$ = $1;}
    | HEX_CONSTANT														{$1->is_constant=1; $$ = $1;}
		| CHAR_CONSTANT														{$1->is_constant=1; $$ = $1;}
		| FLOAT_CONSTANT													{$1->is_constant=1; $$ = $1;}
    ;

array_access: identifier '[' array_index ']'								{
																															if(is_declaration)
																															{
																																if($3->value <= 0)
																																	yyerror("size of array is not positive");

																																else
                                                                                                                                if($3->is_constant && !rhs)
																																	$1->array_dimension = $3->value;
																																	else if(rhs){
																																	{
																																if($3->value > $1->array_dimension)
																																	yyerror("Array index out of bound");

																																if($3->value < 0)
																																	yyerror("Array index cannot be negative");
																															}
																															}
																															}

																															else if($3->is_constant)
																															{
																																if($3->value > $1->array_dimension)
																																	yyerror("Array index out of bound");

																																if($3->value < 0)
																																	yyerror("Array index cannot be negative");
																															}
																															$$ = $1->data_type;
																														}

array_index: constant																		{$$ = $1;}
					 | identifier																	{$$ = $1;}
					 ;

function_call: identifier '(' parameter_list ')'				{
																													$$ = $1->data_type;
																													check_parameter_list($1,param_list,p_idx);
																													p_idx = 0;
																												}

             | identifier '(' ')'												{
							 																						 $$ = $1->data_type;
																													 check_parameter_list($1,param_list,p_idx);
																													 p_idx = 0;
																												}
             ;

parameter_list:
              parameter_list ','  parameter
              |parameter
              ;

parameter: sub_expr																			{param_list[p_idx++] = $1;}
				 | STRING																				{param_list[p_idx++] = STRING;}
				 ;
%%

#define ANSI_COLOR_RED		"\x1b[31m"
#define ANSI_COLOR_GREEN	"\x1b[32m"
#define ANSI_COLOR_YELLOW	"\x1b[33m"
#define ANSI_COLOR_RESET	"\x1b[0m"

void type_check(int left, int right, int flag)
{
	if(left != right)
	{
		switch(flag)
		{
			case 0: yyerror("Type mismatch in arithmetic expression"); break;
			case 1: yyerror("Type mismatch in assignment expression"); break;
			case 2: yyerror("Type mismatch in logical expression"); break;
		}
	}
}

int main(int argc, char *argv[])
{
	int itr;
	for(itr = 0; itr <NUM_TABLES; itr++)
	 {
	  symbol_table_list[itr].symbol_table = NULL;
	  symbol_table_list[itr].parent = -1;
	}

	constant_table = create_table();
	symbol_table_list[0].symbol_table = create_table();
	yyin = fopen(argv[1], "r");

	if(!yyparse())
	{
		printf(ANSI_COLOR_GREEN "\nStatus: PARSING COMPLETE\n" ANSI_COLOR_RESET "\n");
	}
	else
	{
		printf(ANSI_COLOR_RED "\nStatus: PARSING FAILED!\n" ANSI_COLOR_RESET "\n");
	}

	printf("\n\n\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* STRUCTURE TABLE *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n\n");
	display_all();

	printf("\n\n\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* CONSTANT TABLE *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n\n");
	display_constant_table(constant_table);


	fclose(yyin);
	return 0;
}

int yyerror(char *msg)
{
	printf(ANSI_COLOR_YELLOW "\nLine %d : %s Token: %s\n" ANSI_COLOR_RESET, yylineno, msg, yytext);
	printf(ANSI_COLOR_RED "\nStatus: PARSING FAILED!" ANSI_COLOR_RESET "\n");
	exit(0);
}
